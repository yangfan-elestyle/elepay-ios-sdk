#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
#ifndef STRIPE_SWIFT_H
#define STRIPE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StripeApplePay;
@import StripePayments;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="Stripe",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)




@class STPApplePayContext;
@class STPPaymentMethod;
@class PKPayment;
@class NSString;

/// Implement the required methods of this delegate to supply a PaymentIntent to STPApplePayContext and be notified of the completion of the Apple Pay payment.
/// You may also implement the optional delegate methods to handle shipping methods and shipping address changes e.g. to verify you can ship to the address, or update the payment amount.
SWIFT_PROTOCOL("_TtP6Stripe26STPApplePayContextDelegate_")
@protocol STPApplePayContextDelegate <_stpinternal_STPApplePayContextDelegateBase>
/// Called after the customer has authorized Apple Pay.  Implement this method to call the completion block with the client secret of a PaymentIntent or SetupIntent.
/// \param paymentMethod The PaymentMethod that represents the customer’s Apple Pay payment method.
/// If you create the PaymentIntent with confirmation_method=manual, pass <code>paymentMethod.stripeId</code> as the payment_method and confirm=true. Otherwise, you can ignore this parameter.
///
/// \param paymentInformation The underlying PKPayment created by Apple Pay.
/// If you create the PaymentIntent with confirmation_method=manual, you can collect shipping information using its <code>shippingContact</code> and <code>shippingMethod</code> properties.
///
/// \param completion Call this with the PaymentIntent or SetupIntent client secret, or the error that occurred creating the PaymentIntent or SetupIntent.
///
- (void)applePayContext:(STPApplePayContext * _Nonnull)context didCreatePaymentMethod:(STPPaymentMethod * _Nonnull)paymentMethod paymentInformation:(PKPayment * _Nonnull)paymentInformation completion:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completion;
/// Called after the Apple Pay sheet is dismissed with the result of the payment.
/// Your implementation could stop a spinner and display a receipt view or error to the customer, for example.
/// \param status The status of the payment
///
/// \param error The error that occurred, if any.
///
- (void)applePayContext:(STPApplePayContext * _Nonnull)context didCompleteWithStatus:(enum STPPaymentStatus)status error:(NSError * _Nullable)error;
@end

@class NSObject;

/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
SWIFT_PROTOCOL("_TtP6Stripe31STPCustomerEphemeralKeyProvider_")
@protocol STPCustomerEphemeralKeyProvider <NSObject>
/// Creates a new ephemeral key for retrieving and updating a Stripe customer.
/// On your backend, you should create a new ephemeral key for the Stripe customer
/// associated with your user, and return the raw JSON response from the Stripe API.
/// For an example Ruby implementation of this API, refer to our example backend:
/// https://github.com/stripe/example-mobile-backend/blob/v18.1.0/web.rb
/// Back in your iOS app, once you have a response from this API, call the provided
/// completion block with the JSON response, or an error if one occurred.
/// \param apiVersion The Stripe API version to use when creating a key.
/// You should pass this parameter to your backend, and use it to set the API version
/// in your key creation request. Passing this version parameter ensures that the
/// Stripe SDK can always parse the ephemeral key response from your server.
///
/// \param completion Call this callback when you’re done fetching a new ephemeral
/// key from your backend. For example, <code>completion(json, nil)</code> (if your call succeeds)
/// or <code>completion(nil, error)</code> if an error is returned.
///
- (void)createCustomerKeyWithAPIVersion:(NSString * _Nonnull)apiVersion completion:(void (^ _Nonnull)(NSDictionary * _Nullable, NSError * _Nullable))completion;
@end


/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
/// @deprecated use <code>STPCustomerEphemeralKeyProvider</code> or <code>STPIssuingCardEphemeralKeyProvider</code>
/// depending on the type of key that will@objc  be fetched.
SWIFT_PROTOCOL("_TtP6Stripe23STPEphemeralKeyProvider_") SWIFT_DEPRECATED_MSG("use `STPCustomerEphemeralKeyProvider` or `STPIssuingCardEphemeralKeyProvider` depending on the type of key that will be fetched.")
@protocol STPEphemeralKeyProvider <STPCustomerEphemeralKeyProvider>
@end

@class PKAddPaymentPassRequestConfiguration;
@protocol PKAddPaymentPassViewControllerDelegate;
@class NSBundle;
@class NSCoder;

/// This class is a piece of fake UI that is intended to mimic <code>PKAddPaymentPassViewController</code>. That class is restricted to apps with a special entitlement from Apple, and as such can be difficult to build and test against. This class implements the same public API as <code>PKAddPaymentPassViewController</code>, and can be used to develop against the Stripe API in <em>testmode only</em>. (Obviously it will not actually place cards into the user’s Apple Pay wallet either.) When it’s time to go to production, you may simply replace all references to <code>STPFakeAddPaymentPassViewController</code> in your app with <code>PKAddPaymentPassViewController</code> and it will continue to function. For more information on developing against this API, please see https://stripe.com/docs/issuing/cards/digital-wallets .
SWIFT_CLASS("_TtC6Stripe35STPFakeAddPaymentPassViewController")
@interface STPFakeAddPaymentPassViewController : UIViewController
/// @see PKAddPaymentPassViewController
+ (BOOL)canAddPaymentPass SWIFT_WARN_UNUSED_RESULT;
/// @see PKAddPaymentPassViewController
- (nullable instancetype)initWithRequestConfiguration:(PKAddPaymentPassRequestConfiguration * _Nonnull)configuration delegate:(id <PKAddPaymentPassViewControllerDelegate> _Nullable)delegate OBJC_DESIGNATED_INITIALIZER;
/// @see PKAddPaymentPassViewController
@property (nonatomic, weak) id <PKAddPaymentPassViewControllerDelegate> _Nullable delegate;
/// :nodoc:
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
/// :nodoc:
- (void)viewDidLoad;
@end


/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
SWIFT_PROTOCOL("_TtP6Stripe34STPIssuingCardEphemeralKeyProvider_")
@protocol STPIssuingCardEphemeralKeyProvider <NSObject>
/// Creates a new ephemeral key for retrieving and updating a Stripe Issuing Card.
/// On your backend, you should create a new ephemeral key for your logged-in user’s
/// primary Issuing Card, and return the raw JSON response from the Stripe API.
/// For an example Ruby implementation of this API, refer to our example backend:
/// https://github.com/stripe/example-mobile-backend/blob/v18.1.0/web.rb
/// Back in your iOS app, once you have a response from this API, call the provided
/// completion block with the JSON response, or an error if one occurred.
/// \param apiVersion The Stripe API version to use when creating a key.
/// You should pass this parameter to your backend, and use it to set the API version
/// in your key creation request. Passing this version parameter ensures that the
/// Stripe SDK can always parse the ephemeral key response from your server.
///
/// \param completion Call this callback when you’re done fetching a new ephemeral
/// key from your backend. For example, <code>completion(json, nil)</code> (if your call succeeds)
/// or <code>completion(nil, error)</code> if an error is returned.
///
- (void)createIssuingCardKeyWithAPIVersion:(NSString * _Nonnull)apiVersion completion:(void (^ _Nonnull)(NSDictionary * _Nullable, NSError * _Nullable))completion;
@end

@class STPIssuingCardPin;

/// STPAPIClient extensions to manage PIN on Stripe Issuing cards
SWIFT_CLASS("_TtC6Stripe23STPPinManagementService") SWIFT_AVAILABILITY(ios,deprecated=100000.0,message="Please use Issuing Elements instead: https://stripe.com/docs/issuing/elements")
@interface STPPinManagementService : NSObject
/// Create a STPPinManagementService, you must provide an implementation of STPIssuingCardEphemeralKeyProvider
- (nonnull instancetype)initWithKeyProvider:(id <STPIssuingCardEphemeralKeyProvider> _Nonnull)keyProvider OBJC_DESIGNATED_INITIALIZER;
/// Retrieves a PIN number for a given card,
/// this call is asynchronous, implement the completion block to receive the updates
- (void)retrievePin:(NSString * _Nonnull)cardId verificationId:(NSString * _Nonnull)verificationId oneTimeCode:(NSString * _Nonnull)oneTimeCode completion:(void (^ _Nonnull)(STPIssuingCardPin * _Nullable, enum STPPinStatus, NSError * _Nullable))completion;
/// Updates a PIN number for a given card,
/// this call is asynchronous, implement the completion block to receive the updates
- (void)updatePin:(NSString * _Nonnull)cardId newPin:(NSString * _Nonnull)newPin verificationId:(NSString * _Nonnull)verificationId oneTimeCode:(NSString * _Nonnull)oneTimeCode completion:(void (^ _Nonnull)(STPIssuingCardPin * _Nullable, enum STPPinStatus, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PKAddPaymentPassViewController;
@class NSData;
@class PKAddPaymentPassRequest;

/// This class makes it easier to implement “Push Provisioning”, the process by which an end-user can add a card to their Apple Pay wallet without having to type their number. This process is mediated by an Apple class called <code>PKAddPaymentPassViewController</code>; this class will help you implement that class’ delegate methods. Note that this flow requires a special entitlement from Apple; for more information please see https://stripe.com/docs/issuing/cards/digital-wallets .
SWIFT_CLASS("_TtC6Stripe26STPPushProvisioningContext")
@interface STPPushProvisioningContext : NSObject
/// This is a helper method to generate a PKAddPaymentPassRequestConfiguration that will work with
/// Stripe’s Issuing APIs. Pass the returned configuration object to <code>PKAddPaymentPassViewController</code>’s <code>initWithRequestConfiguration:delegate:</code> initializer.
/// @deprecated Use requestConfiguration(withName:description:last4:brand:primaryAccountIdentifier:) instead.
/// \param name Your cardholder’s name. Example: John Appleseed
///
/// \param description A localized description of your card’s name. This will appear in Apple’s UI as “{description} will be available in Wallet”. Example: Platinum Rewards Card
///
/// \param last4 The last 4 of the card to be added to the user’s Apple Pay wallet. Example: 4242
///
/// \param brand The brand of the card. Example: <code>STPCardBrandVisa</code>
///
+ (PKAddPaymentPassRequestConfiguration * _Nonnull)requestConfigurationWithName:(NSString * _Nonnull)name description:(NSString * _Nullable)description last4:(NSString * _Nullable)last4 brand:(enum STPCardBrand)brand SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Use `requestConfiguration(withName:description:last4:brand:primaryAccountIdentifier:)` instead.", "requestConfigurationWithName:description:last4:brand:primaryAccountIdentifier:");
/// This is a helper method to generate a PKAddPaymentPassRequestConfiguration that will work with
/// Stripe’s Issuing APIs. Pass the returned configuration object to <code>PKAddPaymentPassViewController</code>’s <code>initWithRequestConfiguration:delegate:</code> initializer.
/// \param name Your cardholder’s name. Example: John Appleseed
///
/// \param description A localized description of your card’s name. This will appear in Apple’s UI as “{description} will be available in Wallet”. Example: Platinum Rewards Card
///
/// \param last4 The last 4 of the card to be added to the user’s Apple Pay wallet. Example: 4242
///
/// \param brand The brand of the card. Example: <code>STPCardBrandVisa</code>
///
/// \param primaryAccountIdentifier The <code>primary_account_identifier</code> value from the issued card.
///
+ (PKAddPaymentPassRequestConfiguration * _Nonnull)requestConfigurationWithName:(NSString * _Nonnull)name description:(NSString * _Nullable)description last4:(NSString * _Nullable)last4 brand:(enum STPCardBrand)brand primaryAccountIdentifier:(NSString * _Nullable)primaryAccountIdentifier SWIFT_WARN_UNUSED_RESULT;
/// In order to retreive the encrypted payload that PKAddPaymentPassViewController expects, the Stripe SDK must talk to the Stripe API. As this requires privileged access, you must write a “key provider” that generates an Ephemeral Key on your backend and provides it to the SDK when requested. For more information, see https://stripe.com/docs/mobile/ios/basic#ephemeral-key
- (nonnull instancetype)initWithKeyProvider:(id <STPIssuingCardEphemeralKeyProvider> _Nonnull)keyProvider OBJC_DESIGNATED_INITIALIZER;
/// This method lines up with the method of the same name on <code>PKAddPaymentPassViewControllerDelegate</code>. You should implement that protocol in your own app, and when that method is called, call this method on your <code>STPPushProvisioningContext</code>. This in turn will first initiate a call to your <code>keyProvider</code> (see above) to obtain an Ephemeral Key, then make a call to the Stripe Issuing API to fetch an encrypted payload for the card in question, then return that payload to iOS.
- (void)addPaymentPassViewController:(PKAddPaymentPassViewController * _Nonnull)controller generateRequestWithCertificateChain:(NSArray<NSData *> * _Nonnull)certificates nonce:(NSData * _Nonnull)nonce nonceSignature:(NSData * _Nonnull)nonceSignature completionHandler:(void (^ _Nonnull)(PKAddPaymentPassRequest * _Nonnull))handler;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A helper class for turning the raw certificate array, nonce, and nonce signature emitted by PKAddPaymentPassViewController into a format that is understandable by the Stripe API.
/// If you are using STPPushProvisioningContext to implement your integration, you do not need to use this class.
SWIFT_CLASS("_TtC6Stripe32STPPushProvisioningDetailsParams")
@interface STPPushProvisioningDetailsParams : NSObject
/// The Stripe ID of the Issuing card object to retrieve details for.
@property (nonatomic, readonly, copy) NSString * _Nonnull cardId;
/// An array of certificates that should be used to encrypt the card details.
@property (nonatomic, readonly, copy) NSArray<NSData *> * _Nonnull certificates;
/// A nonce that should be used during the encryption of the card details.
@property (nonatomic, readonly, copy) NSData * _Nonnull nonce;
/// A nonce signature that should be used during the encryption of the card details.
@property (nonatomic, readonly, copy) NSData * _Nonnull nonceSignature;
/// Implemented for convenience - the Stripe API expects the certificate chain as an array of base64-encoded strings.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull certificatesBase64;
/// Implemented for convenience - the Stripe API expects the nonce as a hex-encoded string.
@property (nonatomic, readonly, copy) NSString * _Nonnull nonceHex;
/// Implemented for convenience - the Stripe API expects the nonce signature as a hex-encoded string.
@property (nonatomic, readonly, copy) NSString * _Nonnull nonceSignatureHex;
/// Instantiates a new params object with the provided attributes.
- (nonnull instancetype)initWithCardId:(NSString * _Nonnull)cardId certificates:(NSArray<NSData *> * _Nonnull)certificates nonce:(NSData * _Nonnull)nonce nonceSignature:(NSData * _Nonnull)nonceSignature OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
#ifndef STRIPE_SWIFT_H
#define STRIPE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StripeApplePay;
@import StripePayments;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="Stripe",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)




@class STPApplePayContext;
@class STPPaymentMethod;
@class PKPayment;
@class NSString;

/// Implement the required methods of this delegate to supply a PaymentIntent to STPApplePayContext and be notified of the completion of the Apple Pay payment.
/// You may also implement the optional delegate methods to handle shipping methods and shipping address changes e.g. to verify you can ship to the address, or update the payment amount.
SWIFT_PROTOCOL("_TtP6Stripe26STPApplePayContextDelegate_")
@protocol STPApplePayContextDelegate <_stpinternal_STPApplePayContextDelegateBase>
/// Called after the customer has authorized Apple Pay.  Implement this method to call the completion block with the client secret of a PaymentIntent or SetupIntent.
/// \param paymentMethod The PaymentMethod that represents the customer’s Apple Pay payment method.
/// If you create the PaymentIntent with confirmation_method=manual, pass <code>paymentMethod.stripeId</code> as the payment_method and confirm=true. Otherwise, you can ignore this parameter.
///
/// \param paymentInformation The underlying PKPayment created by Apple Pay.
/// If you create the PaymentIntent with confirmation_method=manual, you can collect shipping information using its <code>shippingContact</code> and <code>shippingMethod</code> properties.
///
/// \param completion Call this with the PaymentIntent or SetupIntent client secret, or the error that occurred creating the PaymentIntent or SetupIntent.
///
- (void)applePayContext:(STPApplePayContext * _Nonnull)context didCreatePaymentMethod:(STPPaymentMethod * _Nonnull)paymentMethod paymentInformation:(PKPayment * _Nonnull)paymentInformation completion:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))completion;
/// Called after the Apple Pay sheet is dismissed with the result of the payment.
/// Your implementation could stop a spinner and display a receipt view or error to the customer, for example.
/// \param status The status of the payment
///
/// \param error The error that occurred, if any.
///
- (void)applePayContext:(STPApplePayContext * _Nonnull)context didCompleteWithStatus:(enum STPPaymentStatus)status error:(NSError * _Nullable)error;
@end

@class NSObject;

/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
SWIFT_PROTOCOL("_TtP6Stripe31STPCustomerEphemeralKeyProvider_")
@protocol STPCustomerEphemeralKeyProvider <NSObject>
/// Creates a new ephemeral key for retrieving and updating a Stripe customer.
/// On your backend, you should create a new ephemeral key for the Stripe customer
/// associated with your user, and return the raw JSON response from the Stripe API.
/// For an example Ruby implementation of this API, refer to our example backend:
/// https://github.com/stripe/example-mobile-backend/blob/v18.1.0/web.rb
/// Back in your iOS app, once you have a response from this API, call the provided
/// completion block with the JSON response, or an error if one occurred.
/// \param apiVersion The Stripe API version to use when creating a key.
/// You should pass this parameter to your backend, and use it to set the API version
/// in your key creation request. Passing this version parameter ensures that the
/// Stripe SDK can always parse the ephemeral key response from your server.
///
/// \param completion Call this callback when you’re done fetching a new ephemeral
/// key from your backend. For example, <code>completion(json, nil)</code> (if your call succeeds)
/// or <code>completion(nil, error)</code> if an error is returned.
///
- (void)createCustomerKeyWithAPIVersion:(NSString * _Nonnull)apiVersion completion:(void (^ _Nonnull)(NSDictionary * _Nullable, NSError * _Nullable))completion;
@end


/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
/// @deprecated use <code>STPCustomerEphemeralKeyProvider</code> or <code>STPIssuingCardEphemeralKeyProvider</code>
/// depending on the type of key that will@objc  be fetched.
SWIFT_PROTOCOL("_TtP6Stripe23STPEphemeralKeyProvider_") SWIFT_DEPRECATED_MSG("use `STPCustomerEphemeralKeyProvider` or `STPIssuingCardEphemeralKeyProvider` depending on the type of key that will be fetched.")
@protocol STPEphemeralKeyProvider <STPCustomerEphemeralKeyProvider>
@end

@class PKAddPaymentPassRequestConfiguration;
@protocol PKAddPaymentPassViewControllerDelegate;
@class NSBundle;
@class NSCoder;

/// This class is a piece of fake UI that is intended to mimic <code>PKAddPaymentPassViewController</code>. That class is restricted to apps with a special entitlement from Apple, and as such can be difficult to build and test against. This class implements the same public API as <code>PKAddPaymentPassViewController</code>, and can be used to develop against the Stripe API in <em>testmode only</em>. (Obviously it will not actually place cards into the user’s Apple Pay wallet either.) When it’s time to go to production, you may simply replace all references to <code>STPFakeAddPaymentPassViewController</code> in your app with <code>PKAddPaymentPassViewController</code> and it will continue to function. For more information on developing against this API, please see https://stripe.com/docs/issuing/cards/digital-wallets .
SWIFT_CLASS("_TtC6Stripe35STPFakeAddPaymentPassViewController")
@interface STPFakeAddPaymentPassViewController : UIViewController
/// @see PKAddPaymentPassViewController
+ (BOOL)canAddPaymentPass SWIFT_WARN_UNUSED_RESULT;
/// @see PKAddPaymentPassViewController
- (nullable instancetype)initWithRequestConfiguration:(PKAddPaymentPassRequestConfiguration * _Nonnull)configuration delegate:(id <PKAddPaymentPassViewControllerDelegate> _Nullable)delegate OBJC_DESIGNATED_INITIALIZER;
/// @see PKAddPaymentPassViewController
@property (nonatomic, weak) id <PKAddPaymentPassViewControllerDelegate> _Nullable delegate;
/// :nodoc:
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
/// :nodoc:
- (void)viewDidLoad;
@end


/// You should make your application’s API client conform to this interface.
/// It provides a way for Stripe utility classes to request a new ephemeral key from
/// your backend, which it will use to retrieve and update Stripe API objects.
SWIFT_PROTOCOL("_TtP6Stripe34STPIssuingCardEphemeralKeyProvider_")
@protocol STPIssuingCardEphemeralKeyProvider <NSObject>
/// Creates a new ephemeral key for retrieving and updating a Stripe Issuing Card.
/// On your backend, you should create a new ephemeral key for your logged-in user’s
/// primary Issuing Card, and return the raw JSON response from the Stripe API.
/// For an example Ruby implementation of this API, refer to our example backend:
/// https://github.com/stripe/example-mobile-backend/blob/v18.1.0/web.rb
/// Back in your iOS app, once you have a response from this API, call the provided
/// completion block with the JSON response, or an error if one occurred.
/// \param apiVersion The Stripe API version to use when creating a key.
/// You should pass this parameter to your backend, and use it to set the API version
/// in your key creation request. Passing this version parameter ensures that the
/// Stripe SDK can always parse the ephemeral key response from your server.
///
/// \param completion Call this callback when you’re done fetching a new ephemeral
/// key from your backend. For example, <code>completion(json, nil)</code> (if your call succeeds)
/// or <code>completion(nil, error)</code> if an error is returned.
///
- (void)createIssuingCardKeyWithAPIVersion:(NSString * _Nonnull)apiVersion completion:(void (^ _Nonnull)(NSDictionary * _Nullable, NSError * _Nullable))completion;
@end

@class STPIssuingCardPin;

/// STPAPIClient extensions to manage PIN on Stripe Issuing cards
SWIFT_CLASS("_TtC6Stripe23STPPinManagementService") SWIFT_AVAILABILITY(ios,deprecated=100000.0,message="Please use Issuing Elements instead: https://stripe.com/docs/issuing/elements")
@interface STPPinManagementService : NSObject
/// Create a STPPinManagementService, you must provide an implementation of STPIssuingCardEphemeralKeyProvider
- (nonnull instancetype)initWithKeyProvider:(id <STPIssuingCardEphemeralKeyProvider> _Nonnull)keyProvider OBJC_DESIGNATED_INITIALIZER;
/// Retrieves a PIN number for a given card,
/// this call is asynchronous, implement the completion block to receive the updates
- (void)retrievePin:(NSString * _Nonnull)cardId verificationId:(NSString * _Nonnull)verificationId oneTimeCode:(NSString * _Nonnull)oneTimeCode completion:(void (^ _Nonnull)(STPIssuingCardPin * _Nullable, enum STPPinStatus, NSError * _Nullable))completion;
/// Updates a PIN number for a given card,
/// this call is asynchronous, implement the completion block to receive the updates
- (void)updatePin:(NSString * _Nonnull)cardId newPin:(NSString * _Nonnull)newPin verificationId:(NSString * _Nonnull)verificationId oneTimeCode:(NSString * _Nonnull)oneTimeCode completion:(void (^ _Nonnull)(STPIssuingCardPin * _Nullable, enum STPPinStatus, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class PKAddPaymentPassViewController;
@class NSData;
@class PKAddPaymentPassRequest;

/// This class makes it easier to implement “Push Provisioning”, the process by which an end-user can add a card to their Apple Pay wallet without having to type their number. This process is mediated by an Apple class called <code>PKAddPaymentPassViewController</code>; this class will help you implement that class’ delegate methods. Note that this flow requires a special entitlement from Apple; for more information please see https://stripe.com/docs/issuing/cards/digital-wallets .
SWIFT_CLASS("_TtC6Stripe26STPPushProvisioningContext")
@interface STPPushProvisioningContext : NSObject
/// This is a helper method to generate a PKAddPaymentPassRequestConfiguration that will work with
/// Stripe’s Issuing APIs. Pass the returned configuration object to <code>PKAddPaymentPassViewController</code>’s <code>initWithRequestConfiguration:delegate:</code> initializer.
/// @deprecated Use requestConfiguration(withName:description:last4:brand:primaryAccountIdentifier:) instead.
/// \param name Your cardholder’s name. Example: John Appleseed
///
/// \param description A localized description of your card’s name. This will appear in Apple’s UI as “{description} will be available in Wallet”. Example: Platinum Rewards Card
///
/// \param last4 The last 4 of the card to be added to the user’s Apple Pay wallet. Example: 4242
///
/// \param brand The brand of the card. Example: <code>STPCardBrandVisa</code>
///
+ (PKAddPaymentPassRequestConfiguration * _Nonnull)requestConfigurationWithName:(NSString * _Nonnull)name description:(NSString * _Nullable)description last4:(NSString * _Nullable)last4 brand:(enum STPCardBrand)brand SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Use `requestConfiguration(withName:description:last4:brand:primaryAccountIdentifier:)` instead.", "requestConfigurationWithName:description:last4:brand:primaryAccountIdentifier:");
/// This is a helper method to generate a PKAddPaymentPassRequestConfiguration that will work with
/// Stripe’s Issuing APIs. Pass the returned configuration object to <code>PKAddPaymentPassViewController</code>’s <code>initWithRequestConfiguration:delegate:</code> initializer.
/// \param name Your cardholder’s name. Example: John Appleseed
///
/// \param description A localized description of your card’s name. This will appear in Apple’s UI as “{description} will be available in Wallet”. Example: Platinum Rewards Card
///
/// \param last4 The last 4 of the card to be added to the user’s Apple Pay wallet. Example: 4242
///
/// \param brand The brand of the card. Example: <code>STPCardBrandVisa</code>
///
/// \param primaryAccountIdentifier The <code>primary_account_identifier</code> value from the issued card.
///
+ (PKAddPaymentPassRequestConfiguration * _Nonnull)requestConfigurationWithName:(NSString * _Nonnull)name description:(NSString * _Nullable)description last4:(NSString * _Nullable)last4 brand:(enum STPCardBrand)brand primaryAccountIdentifier:(NSString * _Nullable)primaryAccountIdentifier SWIFT_WARN_UNUSED_RESULT;
/// In order to retreive the encrypted payload that PKAddPaymentPassViewController expects, the Stripe SDK must talk to the Stripe API. As this requires privileged access, you must write a “key provider” that generates an Ephemeral Key on your backend and provides it to the SDK when requested. For more information, see https://stripe.com/docs/mobile/ios/basic#ephemeral-key
- (nonnull instancetype)initWithKeyProvider:(id <STPIssuingCardEphemeralKeyProvider> _Nonnull)keyProvider OBJC_DESIGNATED_INITIALIZER;
/// This method lines up with the method of the same name on <code>PKAddPaymentPassViewControllerDelegate</code>. You should implement that protocol in your own app, and when that method is called, call this method on your <code>STPPushProvisioningContext</code>. This in turn will first initiate a call to your <code>keyProvider</code> (see above) to obtain an Ephemeral Key, then make a call to the Stripe Issuing API to fetch an encrypted payload for the card in question, then return that payload to iOS.
- (void)addPaymentPassViewController:(PKAddPaymentPassViewController * _Nonnull)controller generateRequestWithCertificateChain:(NSArray<NSData *> * _Nonnull)certificates nonce:(NSData * _Nonnull)nonce nonceSignature:(NSData * _Nonnull)nonceSignature completionHandler:(void (^ _Nonnull)(PKAddPaymentPassRequest * _Nonnull))handler;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A helper class for turning the raw certificate array, nonce, and nonce signature emitted by PKAddPaymentPassViewController into a format that is understandable by the Stripe API.
/// If you are using STPPushProvisioningContext to implement your integration, you do not need to use this class.
SWIFT_CLASS("_TtC6Stripe32STPPushProvisioningDetailsParams")
@interface STPPushProvisioningDetailsParams : NSObject
/// The Stripe ID of the Issuing card object to retrieve details for.
@property (nonatomic, readonly, copy) NSString * _Nonnull cardId;
/// An array of certificates that should be used to encrypt the card details.
@property (nonatomic, readonly, copy) NSArray<NSData *> * _Nonnull certificates;
/// A nonce that should be used during the encryption of the card details.
@property (nonatomic, readonly, copy) NSData * _Nonnull nonce;
/// A nonce signature that should be used during the encryption of the card details.
@property (nonatomic, readonly, copy) NSData * _Nonnull nonceSignature;
/// Implemented for convenience - the Stripe API expects the certificate chain as an array of base64-encoded strings.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull certificatesBase64;
/// Implemented for convenience - the Stripe API expects the nonce as a hex-encoded string.
@property (nonatomic, readonly, copy) NSString * _Nonnull nonceHex;
/// Implemented for convenience - the Stripe API expects the nonce signature as a hex-encoded string.
@property (nonatomic, readonly, copy) NSString * _Nonnull nonceSignatureHex;
/// Instantiates a new params object with the provided attributes.
- (nonnull instancetype)initWithCardId:(NSString * _Nonnull)cardId certificates:(NSArray<NSData *> * _Nonnull)certificates nonce:(NSData * _Nonnull)nonce nonceSignature:(NSData * _Nonnull)nonceSignature OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
